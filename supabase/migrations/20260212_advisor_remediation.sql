-- ============================================================
-- Supabase Advisor Remediation Pack (REVIEWED & CORRECTED)
-- Security + Performance fixes
--
-- Original generated by Supabase AI Assistant.
-- Line-by-line audited against actual schema by Claude.
--
-- REMOVED (would break things):
--   - A1: report_shares_public SECURITY INVOKER (is_public column doesn't exist,
--         SECURITY DEFINER is intentional for anon share lookups)
--   - report_access_logs policy changes (advisor changed FROM an EXISTS subquery
--         to a direct user_id match — completely different semantics)
--   - report_shares INSERT policy (advisor removed the EXISTS subquery that
--         verifies you own the report — weakens security)
--   - avatar_videos consolidation (owner_id column doesn't exist on table)
--   - global_comparison_cache policies (table doesn't exist in codebase)
--   - Functions with wrong signatures (corrected below)
--   - cleanup_expired_comparison_cache (function doesn't exist)
--
-- Safe to run on Postgres/Supabase. Run during low traffic.
-- ============================================================


-- ============================================================
-- A) SECURITY: Pin search_path on SECURITY DEFINER functions
-- ============================================================

-- A2a) Zero-argument functions
DO $$
DECLARE
  fn text;
  fns text[] := ARRAY[
    'cleanup_expired_contrast_images',
    'update_reports_updated_at',
    'get_quota_status',
    'reset_monthly_usage',
    'update_invideo_updated_at',
    'update_prompt_updated_at',
    'update_authorized_manual_access_updated_at'
  ];
BEGIN
  FOREACH fn IN ARRAY fns LOOP
    BEGIN
      EXECUTE format('ALTER FUNCTION public.%I() SET search_path = pg_temp, public;', fn);
    EXCEPTION
      WHEN undefined_function THEN
        RAISE NOTICE 'Skipped %.() — not found', fn;
    END;
  END LOOP;
END$$;

-- A2b) Functions WITH arguments — must use exact signatures
DO $$
BEGIN
  -- update_provider_usage(TEXT, DECIMAL)
  BEGIN
    ALTER FUNCTION public.update_provider_usage(TEXT, DECIMAL)
      SET search_path = pg_temp, public;
  EXCEPTION WHEN undefined_function THEN
    RAISE NOTICE 'Skipped update_provider_usage — not found';
  END;

  -- find_invideo_override(TEXT, TEXT)
  BEGIN
    ALTER FUNCTION public.find_invideo_override(TEXT, TEXT)
      SET search_path = pg_temp, public;
  EXCEPTION WHEN undefined_function THEN
    RAISE NOTICE 'Skipped find_invideo_override — not found';
  END;

  -- increment_share_view_count(UUID)
  BEGIN
    ALTER FUNCTION public.increment_share_view_count(UUID)
      SET search_path = pg_temp, public;
  EXCEPTION WHEN undefined_function THEN
    RAISE NOTICE 'Skipped increment_share_view_count — not found';
  END;

  -- get_user_cost_summary(UUID)
  BEGIN
    ALTER FUNCTION public.get_user_cost_summary(UUID)
      SET search_path = pg_temp, public;
  EXCEPTION WHEN undefined_function THEN
    RAISE NOTICE 'Skipped get_user_cost_summary — not found';
  END;

  -- get_user_cost_summary_by_date(UUID, TIMESTAMPTZ, TIMESTAMPTZ)
  BEGIN
    ALTER FUNCTION public.get_user_cost_summary_by_date(UUID, TIMESTAMPTZ, TIMESTAMPTZ)
      SET search_path = pg_temp, public;
  EXCEPTION WHEN undefined_function THEN
    RAISE NOTICE 'Skipped get_user_cost_summary_by_date — not found';
  END;
END$$;


-- ============================================================
-- B) PERFORMANCE: RLS initplan optimization
--    Replace auth.uid() with (SELECT auth.uid()) to avoid
--    per-row re-evaluation. Only for policies where the
--    advisor's logic MATCHES the original exactly.
-- ============================================================

-- ── reports (all 4 ops — straightforward user_id match) ──

DROP POLICY IF EXISTS "Users can view own reports" ON public.reports;
CREATE POLICY "Users can view own reports" ON public.reports
  FOR SELECT TO authenticated
  USING (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can create own reports" ON public.reports;
CREATE POLICY "Users can create own reports" ON public.reports
  FOR INSERT TO authenticated
  WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can update own reports" ON public.reports;
CREATE POLICY "Users can update own reports" ON public.reports
  FOR UPDATE TO authenticated
  USING (user_id = (SELECT auth.uid()))
  WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can delete own reports" ON public.reports;
CREATE POLICY "Users can delete own reports" ON public.reports
  FOR DELETE TO authenticated
  USING (user_id = (SELECT auth.uid()));

-- ── report_access_logs — SKIPPED ──
-- The advisor changed SELECT from an EXISTS subquery (report owner sees all
-- logs for their reports) to a direct user_id match (different semantics).
-- The advisor changed INSERT from auth.uid() IS NOT NULL to user_id = auth.uid()
-- which would break anonymous access logging.
-- Leaving current policies untouched.

-- ── report_shares (SELECT, UPDATE, DELETE only — NOT INSERT) ──

DROP POLICY IF EXISTS "Users can view own shares" ON public.report_shares;
CREATE POLICY "Users can view own shares" ON public.report_shares
  FOR SELECT TO authenticated
  USING (shared_by = (SELECT auth.uid()));

-- INSERT intentionally NOT changed — the original has an EXISTS subquery
-- that verifies the user OWNS the report being shared. The advisor replaced
-- this with just shared_by = auth.uid() which is weaker and would let users
-- create shares for reports they don't own.

DROP POLICY IF EXISTS "Users can update own shares" ON public.report_shares;
CREATE POLICY "Users can update own shares" ON public.report_shares
  FOR UPDATE TO authenticated
  USING (shared_by = (SELECT auth.uid()))
  WITH CHECK (shared_by = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can delete own shares" ON public.report_shares;
CREATE POLICY "Users can delete own shares" ON public.report_shares
  FOR DELETE TO authenticated
  USING (shared_by = (SELECT auth.uid()));

-- ── consent_logs ──

DROP POLICY IF EXISTS "Users can view own consent logs" ON public.consent_logs;
CREATE POLICY "Users can view own consent logs" ON public.consent_logs
  FOR SELECT TO authenticated
  USING (user_id IS NOT NULL AND user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Authenticated users can insert own consent logs" ON public.consent_logs;
CREATE POLICY "Authenticated users can insert own consent logs" ON public.consent_logs
  FOR INSERT TO authenticated
  WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Service role full access" ON public.consent_logs;
CREATE POLICY "Service role full access" ON public.consent_logs
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- ── api_quota_settings: consolidate overlapping SELECT policies ──

DROP POLICY IF EXISTS "Anyone can read quota settings" ON public.api_quota_settings;
DROP POLICY IF EXISTS "Service role manages quota settings" ON public.api_quota_settings;

CREATE POLICY "Quota settings public read"
  ON public.api_quota_settings
  FOR SELECT TO anon, authenticated
  USING (true);

CREATE POLICY "Quota settings service manage"
  ON public.api_quota_settings
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- ── api_quota_alert_log ──

DROP POLICY IF EXISTS "Service role manages alert log" ON public.api_quota_alert_log;
CREATE POLICY "alert_log_service_all"
  ON public.api_quota_alert_log
  FOR ALL TO service_role
  USING (true) WITH CHECK (true);

-- ── contrast_image_cache: restrict writes to service_role only ──
-- (API uses SUPABASE_SERVICE_ROLE_KEY, no client-side inserts)

DROP POLICY IF EXISTS "contrast_image_cache_insert" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_insert"
  ON public.contrast_image_cache
  FOR INSERT TO service_role
  WITH CHECK (true);

DROP POLICY IF EXISTS "contrast_image_cache_update" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_update"
  ON public.contrast_image_cache
  FOR UPDATE TO service_role
  USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "contrast_image_cache_delete" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_delete"
  ON public.contrast_image_cache
  FOR DELETE TO service_role
  USING (true);

-- ── judge_reports (all 4 ops) ──

DROP POLICY IF EXISTS "judge_reports_select" ON public.judge_reports;
CREATE POLICY "judge_reports_select"
  ON public.judge_reports
  FOR SELECT TO authenticated
  USING (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_insert" ON public.judge_reports;
CREATE POLICY "judge_reports_insert"
  ON public.judge_reports
  FOR INSERT TO authenticated
  WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_update" ON public.judge_reports;
CREATE POLICY "judge_reports_update"
  ON public.judge_reports
  FOR UPDATE TO authenticated
  USING (user_id = (SELECT auth.uid()))
  WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_delete" ON public.judge_reports;
CREATE POLICY "judge_reports_delete"
  ON public.judge_reports
  FOR DELETE TO authenticated
  USING (user_id = (SELECT auth.uid()));

-- ── global_comparison_cache — SKIPPED ──
-- Table does not exist anywhere in the codebase.

-- ── avatar_videos — SKIPPED ──
-- The advisor referenced owner_id which doesn't exist on the table.
-- Current policies (avatar_videos_select_completed + avatar_videos_select_auth
-- + avatar_videos_service_role) are correct for the schema.


-- ============================================================
-- C) INDEXES
-- ============================================================

-- C1) Safety net: ensure RLS-filter indexes exist (no-ops if present)
CREATE INDEX IF NOT EXISTS idx_reports_user_id ON public.reports(user_id);
CREATE INDEX IF NOT EXISTS idx_report_access_logs_user_id ON public.report_access_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_report_shares_shared_by ON public.report_shares(shared_by);
CREATE INDEX IF NOT EXISTS idx_judge_reports_user_id ON public.judge_reports(user_id);

-- C2) Drop duplicate indexes (conditional, safe)

-- contrast_image_cache: keep idx_contrast_image_cache_expires_at, drop old name
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_class WHERE relname = 'idx_contrast_expires') THEN
    EXECUTE 'DROP INDEX IF EXISTS public.idx_contrast_expires;';
  END IF;
END$$;

-- user_preferences: keep the UNIQUE key, drop the redundant explicit index
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_class WHERE relname = 'user_preferences_user_id_idx') THEN
    EXECUTE 'DROP INDEX IF EXISTS public.user_preferences_user_id_idx;';
  END IF;
END$$;

-- C3) Unused indexes: DO NOT auto-drop.
-- Monitor pg_stat_user_indexes for 7-14 days first.
-- DROP INDEX IF EXISTS public.idx_reports_status;
-- DROP INDEX IF EXISTS public.idx_reports_created_at;


-- ============================================================
-- Done. Verify with:
-- ============================================================

-- Check search_path pinning:
-- SELECT p.proname, p.proconfig
-- FROM pg_proc p JOIN pg_namespace n ON n.oid = p.pronamespace
-- WHERE n.nspname = 'public'
--   AND p.proname IN (
--     'cleanup_expired_contrast_images','update_reports_updated_at',
--     'get_quota_status','reset_monthly_usage','update_provider_usage',
--     'find_invideo_override','update_invideo_updated_at',
--     'update_prompt_updated_at','update_authorized_manual_access_updated_at',
--     'increment_share_view_count','get_user_cost_summary',
--     'get_user_cost_summary_by_date'
--   );
