-- ============================================================
-- Supabase Advisor Remediation Pack
-- Security + Performance fixes
-- Generated by Supabase AI Assistant, reviewed and corrected.
-- Safe to run on Postgres/Supabase. Run during low traffic.
-- ============================================================

-- ============================================================
-- A) SECURITY
-- ============================================================

-- A1) SKIPPED: report_shares_public view
-- The Supabase advisor flagged this as SECURITY DEFINER, but it is
-- intentional. Anonymous users need to look up shared reports by token,
-- and auth.uid() is null for anon, so SECURITY INVOKER would block them.
-- The view IS the security boundary — it hides password_hash.
-- Additionally, the suggested filter (is_public = true) references a
-- column that does not exist on report_shares.

-- A2) Functions: Pin search_path to avoid mutable resolution
DO $$
DECLARE
  fn text;
  fns text[] := ARRAY[
    'cleanup_expired_contrast_images',
    'update_reports_updated_at',
    'cleanup_expired_comparison_cache',
    'get_quota_status',
    'update_provider_usage',
    'reset_monthly_usage',
    'find_invideo_override',
    'update_invideo_updated_at',
    'update_prompt_updated_at',
    'update_authorized_manual_access_updated_at',
    'increment_share_view_count',
    'get_user_cost_summary',
    'get_user_cost_summary_by_date'
  ];
BEGIN
  FOREACH fn IN ARRAY fns LOOP
    BEGIN
      EXECUTE format('ALTER FUNCTION public.%I() SET search_path = pg_temp, public;', fn);
    EXCEPTION
      WHEN undefined_function THEN
        RAISE NOTICE 'Skipped ALTER FUNCTION %.() — function not found or has args; adjust signature if needed', fn;
    END;
  END LOOP;
END$$;

-- ============================================================
-- B) PERFORMANCE
-- ============================================================

-- B1) RLS policies: Replace auth.uid() with (SELECT auth.uid())
--     to avoid per-row re-evaluation (initplan optimization)

-- reports
DROP POLICY IF EXISTS "Users can view own reports" ON public.reports;
CREATE POLICY "Users can view own reports" ON public.reports
FOR SELECT TO authenticated
USING (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can create own reports" ON public.reports;
CREATE POLICY "Users can create own reports" ON public.reports
FOR INSERT TO authenticated
WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can update own reports" ON public.reports;
CREATE POLICY "Users can update own reports" ON public.reports
FOR UPDATE TO authenticated
USING (user_id = (SELECT auth.uid()))
WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can delete own reports" ON public.reports;
CREATE POLICY "Users can delete own reports" ON public.reports
FOR DELETE TO authenticated
USING (user_id = (SELECT auth.uid()));

-- report_access_logs
DROP POLICY IF EXISTS "Users can view own report logs" ON public.report_access_logs;
CREATE POLICY "Users can view own report logs" ON public.report_access_logs
FOR SELECT TO authenticated
USING (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Authenticated users can insert own access logs" ON public.report_access_logs;
CREATE POLICY "Authenticated users can insert own access logs" ON public.report_access_logs
FOR INSERT TO authenticated
WITH CHECK (user_id = (SELECT auth.uid()));

-- report_shares
DROP POLICY IF EXISTS "Users can view own shares" ON public.report_shares;
CREATE POLICY "Users can view own shares" ON public.report_shares
FOR SELECT TO authenticated
USING (shared_by = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can create shares for own reports" ON public.report_shares;
CREATE POLICY "Users can create shares for own reports" ON public.report_shares
FOR INSERT TO authenticated
WITH CHECK (shared_by = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can update own shares" ON public.report_shares;
CREATE POLICY "Users can update own shares" ON public.report_shares
FOR UPDATE TO authenticated
USING (shared_by = (SELECT auth.uid()))
WITH CHECK (shared_by = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Users can delete own shares" ON public.report_shares;
CREATE POLICY "Users can delete own shares" ON public.report_shares
FOR DELETE TO authenticated
USING (shared_by = (SELECT auth.uid()));

-- consent_logs
DROP POLICY IF EXISTS "Users can view own consent logs" ON public.consent_logs;
CREATE POLICY "Users can view own consent logs" ON public.consent_logs
FOR SELECT TO authenticated
USING (
  (user_id IS NOT NULL AND user_id = (SELECT auth.uid()))
);

DROP POLICY IF EXISTS "Authenticated users can insert own consent logs" ON public.consent_logs;
CREATE POLICY "Authenticated users can insert own consent logs" ON public.consent_logs
FOR INSERT TO authenticated
WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "Service role full access" ON public.consent_logs;
CREATE POLICY "Service role full access" ON public.consent_logs
FOR ALL TO service_role
USING (true) WITH CHECK (true);

-- api_quota_settings: consolidate overlapping SELECT policies
DROP POLICY IF EXISTS "Anyone can read quota settings" ON public.api_quota_settings;
DROP POLICY IF EXISTS "Service role manages quota settings" ON public.api_quota_settings;

CREATE POLICY "Quota settings public read"
ON public.api_quota_settings
FOR SELECT TO anon, authenticated, dashboard_user
USING (true);

CREATE POLICY "Quota settings service manage"
ON public.api_quota_settings
FOR ALL TO service_role
USING (true) WITH CHECK (true);

-- api_quota_alert_log
DROP POLICY IF EXISTS "Service role manages alert log" ON public.api_quota_alert_log;
CREATE POLICY "alert_log_service_all"
ON public.api_quota_alert_log
FOR ALL TO service_role
USING (true) WITH CHECK (true);

-- contrast_image_cache: restrict writes to service_role
DROP POLICY IF EXISTS "contrast_image_cache_insert" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_insert"
ON public.contrast_image_cache
FOR INSERT TO service_role
WITH CHECK (true);

DROP POLICY IF EXISTS "contrast_image_cache_update" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_update"
ON public.contrast_image_cache
FOR UPDATE TO service_role
USING (true) WITH CHECK (true);

DROP POLICY IF EXISTS "contrast_image_cache_delete" ON public.contrast_image_cache;
CREATE POLICY "contrast_image_cache_delete"
ON public.contrast_image_cache
FOR DELETE TO service_role
USING (true);

-- judge_reports
DROP POLICY IF EXISTS "judge_reports_select" ON public.judge_reports;
CREATE POLICY "judge_reports_select"
ON public.judge_reports
FOR SELECT TO authenticated
USING (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_insert" ON public.judge_reports;
CREATE POLICY "judge_reports_insert"
ON public.judge_reports
FOR INSERT TO authenticated
WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_update" ON public.judge_reports;
CREATE POLICY "judge_reports_update"
ON public.judge_reports
FOR UPDATE TO authenticated
USING (user_id = (SELECT auth.uid()))
WITH CHECK (user_id = (SELECT auth.uid()));

DROP POLICY IF EXISTS "judge_reports_delete" ON public.judge_reports;
CREATE POLICY "judge_reports_delete"
ON public.judge_reports
FOR DELETE TO authenticated
USING (user_id = (SELECT auth.uid()));

-- global_comparison_cache: service_role only
DROP POLICY IF EXISTS "Only service role can insert cache" ON public.global_comparison_cache;
CREATE POLICY "global_cache_service_insert"
ON public.global_comparison_cache
FOR INSERT TO service_role
WITH CHECK (true);

DROP POLICY IF EXISTS "Only service role can update cache" ON public.global_comparison_cache;
CREATE POLICY "global_cache_service_update"
ON public.global_comparison_cache
FOR UPDATE TO service_role
USING (true) WITH CHECK (true);

-- avatar_videos: consolidate multiple permissive SELECT for 'authenticated'
DROP POLICY IF EXISTS avatar_videos_select_auth ON public.avatar_videos;
DROP POLICY IF EXISTS avatar_videos_select_completed ON public.avatar_videos;

CREATE POLICY avatar_videos_select
ON public.avatar_videos
FOR SELECT TO authenticated
USING (
  (owner_id = (SELECT auth.uid()))
  OR (status = 'completed')
);

-- ============================================================
-- B1.1) Indexes for RLS-filter columns (no-ops if exist)
-- ============================================================

CREATE INDEX IF NOT EXISTS idx_reports_user_id ON public.reports(user_id);
CREATE INDEX IF NOT EXISTS idx_report_access_logs_user_id ON public.report_access_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_report_shares_shared_by ON public.report_shares(shared_by);
CREATE INDEX IF NOT EXISTS idx_judge_reports_user_id ON public.judge_reports(user_id);

-- ============================================================
-- B2) Duplicate indexes: drop duplicates
-- ============================================================

-- contrast_image_cache: keep idx_contrast_image_cache_expires_at, drop old name
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_class WHERE relname='idx_contrast_expires') THEN
    EXECUTE 'DROP INDEX IF EXISTS public.idx_contrast_expires;';
  END IF;
END$$;

-- user_preferences: keep the UNIQUE key, drop the redundant index
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_class WHERE relname='user_preferences_user_id_idx') THEN
    EXECUTE 'DROP INDEX IF EXISTS public.user_preferences_user_id_idx;';
  END IF;
END$$;

-- ============================================================
-- B3) Unused indexes: DO NOT auto-drop.
-- Monitor pg_stat_user_indexes for 7-14 days first.
-- Uncomment only after confirming idx_scan=0.
-- ============================================================
-- DROP INDEX IF EXISTS public.idx_reports_status;
-- DROP INDEX IF EXISTS public.idx_reports_created_at;

-- ============================================================
-- Done. Run verification queries below manually to confirm.
-- ============================================================

-- Verify functions have pinned search_path:
-- SELECT n.nspname, p.proname, p.proconfig
-- FROM pg_proc p JOIN pg_namespace n ON n.oid = p.pronamespace
-- WHERE n.nspname='public' AND p.proname IN (
--   'cleanup_expired_contrast_images','update_reports_updated_at',
--   'cleanup_expired_comparison_cache','get_quota_status',
--   'update_provider_usage','reset_monthly_usage','find_invideo_override',
--   'update_invideo_updated_at','update_prompt_updated_at',
--   'update_authorized_manual_access_updated_at',
--   'increment_share_view_count','get_user_cost_summary',
--   'get_user_cost_summary_by_date'
-- );

-- Verify duplicate indexes removed:
-- SELECT schemaname, tablename, indexname
-- FROM pg_indexes WHERE schemaname='public'
--   AND tablename IN ('contrast_image_cache','user_preferences')
-- ORDER BY 1,2,3;
